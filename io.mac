%ifndef IO_MAC
%define IO_MAC

%macro read 2
    mov rax, 0  ; read syscall
    mov rdi, 0  ; stdin
    mov rsi, %1 ; read to
    mov rdx, %2 ; how many max to read
    syscall     ; actually read

; This zero escapes the sequence
    mov rax, -1  ; indexer
    mov cl, 0xA  ; newline

    %%loop:
    inc rax
    cmp rax, %2
    jge %%end
    mov dl, [%1+rax] ; array indexing. Index = 1 byte
    cmp cl, dl
    je %%end
    test cl, cl
    jne %%loop

    %%end mov byte [%1+rax], 0
%endmacro

%macro puts 1
    strlen %1   ; length of %1 in rax
    mov rdx, rax
    mov rax, 1  ; write syscall
    mov rdi, 1  ; stdout
    mov rsi, %1 ; read from
    syscall
%endmacro

%macro strlen 1
    mov rax, -1
    xor rdx, rdx
    %%count_loop:
    inc rax
    mov dl, [%1+rax]
    test dl, dl
    jnz %%count_loop
%endmacro

%macro exit 1
    mov rax, 60 ; exit syscall
    mov rdi, %1 ; exit value
    syscall
%endmacro

%macro putc 1
    mov rax, 1
    mov rdi, 1
    mov rsi, %1
    mov rdx, 1
    syscall
%endmacro

; rdi => const char * format_string
; rsi, rdx, rcx, r8, r9 => rest of the things
global printf
printf:
    push rbp
    mov rbp, rsp
    sub rsp, 2   ; save and start the stack frame
                 ; 2 chars
    push r12     ; Push registers we'll use
    push r13
    push r14
    push r15

    mov r12, 0    ; index
    mov r13, rdi  ; char array
    mov r14, rsi  ; arguments
    printf_loop:
        mov cl, [r13+r12]
        test cl, cl
        jz printf_end
        cmp cl, 0x25 ; is cl a %?
        jz printf_what_type ; yes
        mov [rsp], cl ; no
        putc rsp
        inc r12
        jmp printf_loop

    printf_what_type:
        inc r12
        mov cl, [r13+r12]
        cmp cl, 0x73 ; s
        je printf_str
        cmp cl, 0x25 ; %
        je printf_percent_sign
        jmp printf_loop

    printf_str:
        puts r14
        inc r12
        jmp printf_loop

    printf_percent_sign:
        mov byte [rsp], 0x25
        putc rsp
        jmp printf_loop

    printf_end:
        pop r12
        pop r13
        pop r14
        pop r15
        mov rsp, rbp
        pop rbp
        ret

%endif
